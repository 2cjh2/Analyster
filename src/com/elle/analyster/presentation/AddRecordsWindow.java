
package com.elle.analyster.presentation;

import com.elle.analyster.logic.Tab;
import com.elle.analyster.logic.Validator;
import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;

/**
 *
 * @author Louis W.
 * @author cigreja
 */
public class AddRecordsWindow extends JFrame {

    // attributes
    private String[] columnNames;
    private String tableName;
    private int numRowsAdded;           // number of rows added counter
    private Map<String,Tab> tabs;       // used to update the records label
    private Statement statement;
    
    // components
    private AnalysterWindow analyster;
    private LogWindow logWindow;
    private DefaultTableModel model;

    /**
     * Creates new form AddRecordsWindow
     */
    public AddRecordsWindow() {
        
        // initialize components
        initComponents();
        analyster = AnalysterWindow.getInstance();
        logWindow = analyster.getLogwind();
        tabs = analyster.getTabs();
        statement = analyster.getStatement();
        
        // set this window to appear in the middle of Analyster
        this.setLocationRelativeTo(analyster);
        
        // set the selected table name
        tableName = analyster.getSelectedTab();
        
        // set the label header
        this.setTitle("Add Records to " + tableName);
        
        // create a new empty table
        createEmptyTable();
        
        // sets the keyboard focus manager
        setKeyboardFocusManager();   
        
        // add listeners
        addTableListeners();
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel3 = new javax.swing.JPanel();
        scrollpane = new javax.swing.JScrollPane();
        table = new javax.swing.JTable();
        btnSubmit = new javax.swing.JButton();
        btnCancel = new javax.swing.JButton();
        btnAddRow = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setMinimumSize(new java.awt.Dimension(550, 200));

        scrollpane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        scrollpane.setMaximumSize(new java.awt.Dimension(260, 100));
        scrollpane.setMinimumSize(new java.awt.Dimension(130, 50));

        table.setAutoCreateRowSorter(true);
        table.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null}
            },
            new String [] {
                "symbol", "analyst", "priority", "dateAssigned", "note"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        table.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                tableMouseClicked(evt);
            }
        });
        table.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                tableKeyPressed(evt);
            }
        });
        scrollpane.setViewportView(table);

        btnSubmit.setText("Submit");
        btnSubmit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSubmitActionPerformed(evt);
            }
        });

        btnCancel.setText("Cancel");
        btnCancel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCancelActionPerformed(evt);
            }
        });

        btnAddRow.setText("+");
        btnAddRow.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAddRowActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(btnAddRow)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 445, Short.MAX_VALUE)
                .addComponent(btnSubmit)
                .addGap(18, 18, 18)
                .addComponent(btnCancel)
                .addContainerGap())
            .addComponent(scrollpane, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                .addComponent(scrollpane, javax.swing.GroupLayout.DEFAULT_SIZE, 179, Short.MAX_VALUE)
                .addGap(12, 12, 12)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnSubmit)
                    .addComponent(btnCancel)
                    .addComponent(btnAddRow))
                .addGap(12, 12, 12))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * jSubmitActionPerformed
     * This is performed when the submit button is executed.
     * Refactored by Carlos Igreja 7-28-2015
     * @param evt 
     */
    private void btnSubmitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSubmitActionPerformed

        submit();
    }//GEN-LAST:event_btnSubmitActionPerformed

    /**
     * submit
     * This is used when the submit button is pressed or if the enter key 
     * is pressed when the table is finished editing to submit the data
     * to the database.
     */
    private void submit(){
        
        Object cellValue = null;                 // store cell value
        int col = 0;                             // column index
        int row = 0;                             // row index
        
        // check if data is valid
        if(validateData()){
            
            // once data checked, execute sql statement
            // first get the insert statement for the table
            String insertInto = "INSERT INTO " + tableName + " (";

            // this table should already not include the primary key
            for (col = 0; col < table.getColumnCount(); col++){
                if(col != table.getColumnCount() -1)
                    insertInto += table.getColumnName(col) + ", ";
                else
                    insertInto += table.getColumnName(col) + ") ";
            }

            numRowsAdded = 0; // reset numRowsAdded counter

            // Now get the values to add to the database
            String values = "";  
            for(row = 0; row < table.getRowCount(); row++){
                values = "VALUES (";  // start the values statement
                for(col = 0; col < table.getColumnCount(); col++){

                    // get cell value
                    cellValue = table.getValueAt(row, col);

                    // format the cell value for sql
                    if(cellValue != null){

                        // if cell is empty it must be null
                        if(cellValue.toString().equals("")){
                            cellValue = null;
                        }

                        // if the cell is not empty it must have single quotes
                        else {
                            cellValue = "'" + cellValue + "'";
                        }
                    }

                    // skip empty rows
                    // this must be after the format cell value so the "" => null
                    if(col == 0 && cellValue == null){
                        break;                      
                    }

                    // add each value for each column to the values statement
                    if(col != table.getColumnCount() -1){
                        values += cellValue + ", ";
                    }
                    else {
                        values += cellValue + ");";
                    }
                }

                try{
                    // execute the sql statement
                    if(!values.equals("VALUES (")){      //skip if nothing was added
                        statement.executeUpdate(insertInto + values);
                        numRowsAdded++;   // increment the number of rows added
                    }
                }
                catch(SQLException sqlException) {
                    try {
                        JOptionPane.showMessageDialog(null, "Upload failed!");

                        if(statement.getWarnings().getMessage() != null){
                            logWindow.writeToTextFile("Upload failed:"); 
                            logWindow.writeToTextFile(statement.getWarnings().getMessage()); 
                        }
                        
                        sqlException.printStackTrace();
                    } // end try-catch
                    catch (SQLException ex) {
                        ex.printStackTrace();
                    }
                }
            }

            if(numRowsAdded > 0){
                // update table and records label
                String selectedTab = analyster.getSelectedTab();                          // get selected tab
                analyster.loadTable(tabs.get(selectedTab).getTable());                    // load table data from database
                tabs.get(selectedTab).getFilter().applyFilter();                          // apply filter
                tabs.get(selectedTab).getFilter().applyColorHeaders();                    // apply color headers
                tabs.get(selectedTab).getColumnPopupMenu().loadAllCheckBoxItems();        // refresh the data for the column pop up
                analyster.setLastUpdateTime();                                            // set the last update time from database
                tabs.get(selectedTab).addToTotalRowCount(numRowsAdded);                   // add the number of records added to the total records count
                String records = tabs.get(selectedTab).getRecordsLabel();                 // store the records label string
                analyster.getRecordsLabel().setText(records);                             // update the records label text
                JOptionPane.showMessageDialog(null, numRowsAdded + " Add successfully!"); // show dialog box that upload was successful
                createEmptyTable();                                                       // create a new table with default 10 rows
            }
        }
    }
    
    private void tableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_tableMouseClicked

    }//GEN-LAST:event_tableMouseClicked

    private void btnCancelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCancelActionPerformed
        this.dispose();
    }//GEN-LAST:event_btnCancelActionPerformed

    private void btnAddRowActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAddRowActionPerformed

        // add an empty row to the table
        model.addRow(new Object[]{});
    }//GEN-LAST:event_btnAddRowActionPerformed

    private void tableKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_tableKeyPressed

    }//GEN-LAST:event_tableKeyPressed
   
    /**
     * setKeyboardFocusManager
     * Sets the Keyboard Focus Manager
     */
    private void setKeyboardFocusManager() {
        
        /*
         No Tab key-pressed or key-released events are received by the key event listener. This is because the focus subsystem 
         consumes focus traversal keys, such as Tab and Shift Tab. To solve this, apply the following to the component that is 
         firing the key events 
         */
        table.setFocusTraversalKeysEnabled(false);
        KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(new KeyEventDispatcher() {// Allow to TAB-

            @Override
            public boolean dispatchKeyEvent(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_TAB) {
                    if (e.getComponent() instanceof JTable) {
                        JTable table = (JTable) e.getComponent();
                        int row = table.getSelectedRow();
                        int column = table.getSelectedColumn();
                        if (column == table.getRowCount() || column == 0) {
                            return false;
                        } 
                        else {
                            table.getComponentAt(row, column).requestFocus();
                            table.editCellAt(row, column);
                            JTextField selectCom = (JTextField) table.getEditorComponent();
                            selectCom.requestFocusInWindow();
                            selectCom.selectAll();
                        }
                    }
                    
                    btnSubmit.setEnabled(!table.isEditing()); 

                } 
                else if (e.getKeyCode() == KeyEvent.VK_D && e.isControlDown()) {
                    JTable table = (JTable) e.getComponent().getParent();
                    int column = table.getSelectedColumn();
                    if (table.getColumnName(column).toLowerCase().contains("date")) {
                        if (e.getID() != 401) {
                            return false;
                        } else {
                            JTextField selectCom = (JTextField) e.getComponent();
                            selectCom.requestFocusInWindow();
                            selectCom.selectAll();
                            DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
                            Date date = new Date();
                            String today = dateFormat.format(date);
                            selectCom.setText(today);
                        }// default date input with today's date}
                    }
                }
                
                // this is called while in the cell editing to finish editing
                else if (e.getKeyCode() == KeyEvent.VK_ENTER && table.isEditing()) {
                    
                    btnSubmit.setEnabled(true);
                }
                return false; 
            }
        });
    }
    
    /**
     * createEmptyTable
     * creates an empty table with default 10 rows
     */
    private void createEmptyTable() {
        // get column names for selected Analyster table
        columnNames = analyster.getTabs().get(tableName).getTableColNames();
        
        // we don't want the ID column 
        columnNames = Arrays.copyOfRange(columnNames, 1, columnNames.length); 
        
        // set the table model - add 10 empty rows
        model = new DefaultTableModel(columnNames, 10);
        
        // add the table model to the table
        table.setModel(model);
    }
    
    /**
     * createEmptyTable
     * creates an empty table with the specified amount of rows
     * @param rows  // number of rows to add to table
     */
    private void createEmptyTable(int rows) {
        // get column names for selected Analyster table
        columnNames = analyster.getTabs().get(tableName).getTableColNames();
        
        // we don't want the ID column 
        columnNames = Arrays.copyOfRange(columnNames, 1, columnNames.length); 
        
        // set the table model - add 10 empty rows
        model = new DefaultTableModel(columnNames, rows);
        
        // add the table model to the table
        table.setModel(model);
    }
    
    /**
     * addTableListeners
     * This is called to add the listeners to the table 
     * The listeners added are the TableModel listener
     * the MouseListener and the KeyListener
     */
    public void addTableListeners(){
        
        // add tableModelListener
        table.getModel().addTableModelListener(new TableModelListener() {

            @Override
            public void tableChanged(TableModelEvent e) {
                
                // check the cell for valid entry
                validateCell(e);
                
            }
        });
        
        // add mouselistener to the table
        table.addMouseListener( new MouseAdapter() {
                    
            @Override
            public void mousePressed(MouseEvent e){

                // select all text
                selectAllText(e);

                // grey out submit button
                btnSubmit.setEnabled(false);
            }
        });
        
        // add keyListener to the table
        table.addKeyListener(new KeyAdapter() {
            
            @Override
            public void keyPressed(KeyEvent ke) {
                
                // in editing mode this should ask to upload changes when enter key press
                if (ke.getKeyCode() == KeyEvent.VK_ENTER && !table.isEditing()) {
                    
                    submit();
                }
            }
        });
    }
    
    /**
     * selectAllText
     * Select all text inside jTextField or a cell
     * @param e 
     */
    private void selectAllText(MouseEvent e) {

        JTable table = (JTable) e.getComponent();
        int row = table.getSelectedRow();
        int column = table.getSelectedColumn();
        if (column != -1) {
            table.getComponentAt(row, column).requestFocus();
            table.editCellAt(row, column);
            JTextField selectCom = (JTextField) table.getEditorComponent();
            if (selectCom != null) {
                selectCom.requestFocusInWindow();
                selectCom.selectAll();
            }
        }
    }
    
    /**
     * validateCell
     * @param e 
     */
    public void validateCell(TableModelEvent e){
        
        String colName = table.getColumnName(e.getColumn()); // column name
        int row = e.getFirstRow();                           // row index
        int col = e.getColumn();                             // column index
        Object cellValue = table.getValueAt(row, col);       // store cell value
        String errorMsg = "Error with " + colName 
                + " in row " + (row + 1) + ".\n";            // error message
        boolean error = false;                               // error occurred

            switch(colName){
                case "symbol":
                    if(cellValue == null || cellValue.toString().equals("")){
                        errorMsg += "Symbol cannot be null";
                        error = true;
                    }
                    break;
                case "analyst":
                    break;
                case "priority":
                    if(cellValue != null && !cellValue.toString().equals(""))
                        if(!cellValue.toString().matches("[1-5]{1}")){
                            errorMsg += "Priority must be an Integer (1-5)";
                            error = true;
                        }
                    break;
                case "dateAssigned":
                    if(cellValue != null && !cellValue.toString().equals("")){
                        if(!Validator.isValidDate("yyyy-MM-dd", cellValue.toString())){
                            errorMsg += "Date format not correct: YYYY-MM-DD";
                            error = true;
                        }
                    }
                    break;
                case "dateDone":
                    if(cellValue != null && !cellValue.toString().equals("")){
                        if(!Validator.isValidDate("yyyy-MM-dd", cellValue.toString())){
                            errorMsg += "Date format not correct: YYYY-MM-DD";
                            error = true;
                        }
                    }
                    break;
                case "notes":
                    break;
                case "author":
                    break;
                case "analysisDate":
                    if(cellValue != null && !cellValue.toString().equals("")){
                        if(!Validator.isValidDate("yyyy-MM-dd", cellValue.toString())){
                            errorMsg += "Date format not correct: YYYY-MM-DD";
                            error = true;
                        }
                    }
                    break;
                case "path":
                    break;
                case "document":
                    break;
                case "notesL":
                    break;
                default:
                    break;

            }// end switch
            
        if(error){
            JOptionPane.showMessageDialog(table, errorMsg);
            btnSubmit.setEnabled(true); 
        }
    }
    
    /**
     * validateData
     * Validates all the data in the table to make sure it is correct.
     * This is used to validate the data before it is executed to the
     * server and the database so that there will not be any errors.
     * 
     * @return returns true if the data is all valid and false if the is a single error
     */
    public boolean validateData(){
        
        String colName = "";            // column name
        Object cellValue = null;        // store cell value
        int col = 0;                    // column index
        int row = 0;                    // row index
        String errorMsg = "";           // error message
        int emptyCells = 0;             // number of empty cells in a row
        boolean error = false;          // error occurred
        
        // check data
        for(row = 0; row < table.getRowCount(); row++){
            
            // if there was an error stop
            if(error)break;

            // reset empty cell count
            emptyCells = 0;

            // first test if row is empty
            for(col = 0; col < table.getColumnCount(); col++){

                // get value of cell
                cellValue = table.getValueAt(row, col);

                // check each column for a value
                if(cellValue == null || cellValue.toString().equals("")){
                    emptyCells++;
                }
            }

            // continue to next row if this one is empty
            if(emptyCells == table.getColumnCount()){
                continue;   
            }

            for(col = 0; col < table.getColumnCount(); col++){
                
                // if there was an error stop
                if(error)break;

                // get column name
                colName = table.getColumnName(col);

                // get value of cell
                cellValue = table.getValueAt(row, col);
                
                // begin error message
                errorMsg = "Error with " + colName + " in row " + (row + 1) + ".\n"; 

                switch(colName){
                    case "symbol":
                        if(cellValue == null || cellValue.toString().equals("")){
                            errorMsg += "Symbol cannot be null";
                            error = true;
                        }
                        break;
                    case "analyst":
                        break;
                    case "priority":
                        if(cellValue != null && !cellValue.toString().equals(""))
                            if(!cellValue.toString().matches("[1-5]{1}")){
                                errorMsg += "Priority must be an Integer (1-5)";
                                error = true;
                            }
                        break;
                    case "dateAssigned":
                        if(cellValue != null && !cellValue.toString().equals("")){
                            if(!Validator.isValidDate("yyyy-MM-dd", cellValue.toString())){
                                errorMsg += "Date format not correct: YYYY-MM-DD";
                                error = true;
                            }
                        }
                        break;
                    case "dateDone":
                        if(cellValue != null && !cellValue.toString().equals("")){
                            if(!Validator.isValidDate("yyyy-MM-dd", cellValue.toString())){
                                errorMsg += "Date format not correct: YYYY-MM-DD";
                                error = true;
                            }
                        }
                        break;
                    case "notes":
                        break;
                    case "author":
                        break;
                    case "analysisDate":
                        if(cellValue != null && !cellValue.toString().equals("")){
                            if(!Validator.isValidDate("yyyy-MM-dd", cellValue.toString())){
                                errorMsg += "Date format not correct: YYYY-MM-DD";
                                error = true;
                            }
                        }
                        break;
                    case "path":
                        break;
                    case "document":
                        break;
                    case "notesL":
                        break;
                    default:
                        break;

                }// end switch
            }// end col for loop
        }// end row for loop
        
        if(error){
            JOptionPane.showMessageDialog(table, errorMsg);
            btnSubmit.setEnabled(true); 
        }
        
        return !error;
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnAddRow;
    private javax.swing.JButton btnCancel;
    private javax.swing.JButton btnSubmit;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane scrollpane;
    private javax.swing.JTable table;
    // End of variables declaration//GEN-END:variables

}
